require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const fetch = require('node-fetch');
const axios = require('axios');

const app = express();

app.use(cors({
  origin: ['http://localhost:5173', 'https://animeinc.vercel.app'],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'], 
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
}));
app.options('*', cors());

app.use(express.json());

// –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ MongoDB
mongoose
  .connect(process.env.MONGO_URI)
  .then(() => {
    console.log('‚úÖ Connected to MongoDB');
    mongoose.connection.db.listCollections().toArray((err, collections) => {
      if (err) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –∫–æ–ª–ª–µ–∫—Ü–∏–π:', err);
      } else {
        console.log('üìå –ö–æ–ª–ª–µ–∫—Ü–∏–∏ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö:', collections.map(col => col.name));
      }
    });
  })
  .catch(err => console.error('‚ùå MongoDB connection error:', err));

// –°—Ö–µ–º–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
const userSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  favorites: [{ type: String }],
  avatar: { type: String, default: 'https://ibb.co.com/qMX1hGDz' },
  role: { type: String, default: 'user', enum: ['user', 'admin'] }, // –†–æ–ª—å: user –∏–ª–∏ admin
}, { collection: 'users' });

const User = mongoose.model('User', userSchema);

const isAdmin = (req, res, next) => {
  if (!req.user || req.user.role !== 'admin') {
    return res.status(403).json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω: —Ç—Ä–µ–±—É–µ—Ç—Å—è —Ä–æ–ª—å –∞–¥–º–∏–Ω–∞' });
  }
  next();
};

// –°—Ö–µ–º–∞ –∞–Ω–∏–º–µ (–æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å)
const animeSchema = new mongoose.Schema({
  Title: { type: String, required: true }, // –†—É—Å—Å–∫–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ
  TitleEng: { type: String, required: true }, // –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ
  Poster: { type: String, required: true }, // URL –ø–æ—Å—Ç–µ—Ä–∞
  Backdrop: { type: String }, // URL –±—ç–∫–¥—Ä–æ–ø–∞ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –ø–æ–ª–µ)
  Year: { type: String, required: true }, // –ì–æ–¥ –≤—ã–ø—É—Å–∫–∞
  Released: { type: String, required: true }, // –î–∞—Ç–∞ —Ä–µ–ª–∏–∑–∞
  imdbRating: { type: String }, // –†–µ–π—Ç–∏–Ω–≥ IMDb
  imdbID: { type: String, required: true, unique: true }, // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä IMDb
  Episodes: { type: Number }, // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ—Ä–∏–π (—á–∏—Å–ª–æ–≤–æ–π —Ç–∏–ø)
  Genre: { type: [String], required: true, default: [] }, // –ñ–∞–Ω—Ä—ã (–º–∞—Å—Å–∏–≤ —Å—Ç—Ä–æ–∫)
  Tags: { type: [String], default: [] }, // –¢–µ–≥–∏ (–º–∞—Å—Å–∏–≤ —Å—Ç—Ä–æ–∫, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø—É—Å—Ç–æ–π)
  OverviewRu: { type: String, required: true }, // –û–ø–∏—Å–∞–Ω–∏–µ –Ω–∞ —Ä—É—Å—Å–∫–æ–º
}, { collection: 'anime_list' });

const Anime = mongoose.model('Anime', animeSchema);

const SECRET_KEY = process.env.JWT_SECRET || 'your-secret-key';

// Middleware –¥–ª—è –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
const authenticateToken = (req, res, next) => {
  const token = req.headers['authorization']?.split(' ')[1];
  if (!token) return res.status(401).json({ message: '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è' });

  jwt.verify(token, SECRET_KEY, (err, user) => {
    if (err) return res.status(403).json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' });
    req.user = user;
    next();
  });
};


// –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–æ–∫–µ–Ω–∞ Turnstile
const verifyTurnstileToken = async (token) => {
  const secretKey = process.env.TURNSTILE_SECRET_KEY || 'YOUR_TURNSTILE_SECRET_KEY'; // –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –æ–∫—Ä—É–∂–µ–Ω–∏—è
  try {
    const response = await axios.post('https://challenges.cloudflare.com/turnstile/v0/siteverify', {
      secret: secretKey,
      response: token,
    });
    return response.data.success; // true, –µ—Å–ª–∏ —Ç–æ–∫–µ–Ω –≤–∞–ª–∏–¥–µ–Ω
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ Turnstile:', error.message);
    return false;
  }
};

// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
app.post('/api/register', async (req, res) => {
  try {
    const { login: username, email, password, turnstileToken, role = 'user' } = req.body;

    // –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    console.log('Register request body:', { username, email, password, turnstileToken, role });

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞ Turnstile
    if (!turnstileToken) {
      return res.status(400).json({ message: '–¢—Ä–µ–±—É–µ—Ç—Å—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–ø—á–∏' });
    }
    const isValidCaptcha = await verifyTurnstileToken(turnstileToken);
    if (!isValidCaptcha) {
      return res.status(400).json({ message: '–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–∞–ø—á–∏' });
    }

    // –í–∞–ª–∏–¥–∞—Ü–∏—è —Ä–æ–ª–∏
    if (!['user', 'admin'].includes(role)) {
      return res.status(400).json({ message: '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º–∞—è —Ä–æ–ª—å. –î–æ—Å—Ç—É–ø–Ω—ã–µ —Ä–æ–ª–∏: user, admin' });
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
    if (!username || !email || !password) {
      return res.status(400).json({ message: '–í—Å–µ –ø–æ–ª—è (username, email, password) –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' });
    }

    // –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª—è
    const hashedPassword = await bcrypt.hash(password, 10);

    // –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = new User({
      username,
      email,
      password: hashedPassword,
      role,
    });

    // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    await user.save();

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è JWT —Ç–æ–∫–µ–Ω–∞
    const token = jwt.sign(
      { id: user._id, username: user.username, role: user.role },
      process.env.JWT_SECRET || 'your-secret-key',
      { expiresIn: '1h' }
    );

    // –û—Ç–≤–µ—Ç –∫–ª–∏–µ–Ω—Ç—É
    res.status(201).json({
      token,
      user: {
        id: user._id,
        username: user.username,
        avatar: user.avatar,
        role: user.role,
      },
    });
  } catch (error) {
    if (error.code === 11000) {
      const field = Object.keys(error.keyPattern)[0];
      return res.status(409).json({ message: `–≠—Ç–æ—Ç ${field} —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω` });
    }
    console.error('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:', error.message);
    res.status(400).json({ message: '–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏', error: error.message });
  }
});

// –í—Ö–æ–¥
app.post('/api/login', async (req, res) => {
  try {
    const { login, password } = req.body; // –£–±—Ä–∞–ª–∏ turnstileToken

    if (!login || !password) {
      return res.status(400).json({ message: '–õ–æ–≥–∏–Ω –∏ –ø–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' });
    }

    // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await User.findOne({
      $or: [{ username: login }, { email: login }],
    });

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –ø–∞—Ä–æ–ª—è
    if (!user) {
      return res.status(401).json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
    }
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      return res.status(401).json({ message: '–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å' });
    }

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è JWT —Ç–æ–∫–µ–Ω–∞
    const token = jwt.sign(
      { id: user._id, username: user.username, role: user.role },
      process.env.JWT_SECRET || 'your-secret-key',
    );

    // –û—Ç–≤–µ—Ç –∫–ª–∏–µ–Ω—Ç—É
    res.json({
      token,
      user: {
        id: user._id,
        username: user.username,
        avatar: user.avatar,
        role: user.role,
      },
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞:', error.message);
    res.status(400).json({ message: '–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞', error: error.message });
  }
});

// –ü—Ä–æ—Ñ–∏–ª—å
app.get('/api/profile', authenticateToken, async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('-password');
    const favorites = user.favorites || [];
    const favoritesData = await Promise.all(
      favorites.map((imdbID) => Anime.findOne({ imdbID }).catch(() => null))
    ).then(results => results.filter(Boolean));
    res.json({ ...user.toObject(), favoritesData });
  } catch (error) {
    res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  }
});

// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ
app.post('/api/favorites', authenticateToken, async (req, res) => {
  try {
    const { imdbID } = req.body;
    const user = await User.findById(req.user.id);
    
    if (!user.favorites.includes(imdbID)) {
      user.favorites.push(imdbID);
      await user.save();
    }
    
    res.json({ success: true, favorites: user.favorites }); // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
  } catch (error) {
    res.status(400).json({ success: false, message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ', error: error.message });
  }
});

// –£–¥–∞–ª–µ–Ω–∏–µ –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ
app.delete('/api/favorites', authenticateToken, async (req, res) => {
  try {
    const { imdbID } = req.body;
    const user = await User.findById(req.user.id);
    
    if (user.favorites.includes(imdbID)) {
      user.favorites = user.favorites.filter(id => id !== imdbID);
      await user.save();
    }
    
    res.json({ success: true, favorites: user.favorites }); // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
  } catch (error) {
    res.status(400).json({ success: false, message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ', error: error.message });
  }
});


// –°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –º–∞—Ä—à—Ä—É—Ç—ã –¥–ª—è –∞–Ω–∏–º–µ
app.get('/api/anime', async (req, res) => {
  try {
    const { genre, search, fields, limit, sort } = req.query;
    let query = {};

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∂–∞–Ω—Ä–æ–≤
    if (genre) {
      // –ï—Å–ª–∏ genre ‚Äî —Å—Ç—Ä–æ–∫–∞, —Ä–∞–∑–±–∏–≤–∞–µ–º –µ—ë –ø–æ –∑–∞–ø—è—Ç—ã–º –∏ –æ–±—Ä–µ–∑–∞–µ–º –ø—Ä–æ–±–µ–ª—ã
      const genreArray = Array.isArray(genre) 
        ? genre.map(g => g.trim()) 
        : genre.toString().split(',').map(g => g.trim()).filter(Boolean);
      
      // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ä—É—Å—Å–∫–∏–µ –∂–∞–Ω—Ä—ã –≤ –∞–Ω–≥–ª–∏–π—Å–∫–∏–µ (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Ä—É—Å—Å–∫–∏–µ –≤ –∑–∞–ø—Ä–æ—Å–µ)
      const genreMapping = {
        "–ê–Ω–∏–º–∞—Ü–∏—è": "Animation",
        "–ö–æ–º–µ–¥–∏—è": "Comedy",
        "–†–æ–º–∞–Ω—Ç–∏–∫–∞": "Romance",
        "–î—Ä–∞–º–∞": "Drama",
        "–≠–∫—à–µ–Ω": "Action",
        // –î–æ–±–∞–≤—å—Ç–µ –¥—Ä—É–≥–∏–µ –º–∞–ø–ø–∏–Ω–≥–∏ –ø–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
      };

      const englishGenres = genreArray.map(g => genreMapping[g] || g); // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –∞–Ω–≥–ª–∏–π—Å–∫–∏–µ, –µ—Å–ª–∏ –µ—Å—Ç—å –º–∞–ø–ø–∏–Ω–≥
      query.Genre = { $in: englishGenres }; // –ò—â–µ–º –∞–Ω–∏–º–µ, —É –∫–æ—Ç–æ—Ä—ã—Ö –≤ –º–∞—Å—Å–∏–≤–µ Genre –µ—Å—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –∏–∑ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –∂–∞–Ω—Ä–æ–≤
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–∏—Å–∫–∞
    if (search) {
      query.$or = [
        { Title: { $regex: new RegExp(search, 'i') } },
        { TitleEng: { $regex: new RegExp(search, 'i') } }
      ];
    }

    let dbQuery = Anime.find(query);
    if (fields) dbQuery = dbQuery.select(fields.split(',').join(' '));
    if (limit) dbQuery = dbQuery.limit(parseInt(limit) || 10); // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –ª–∏–º–∏—Ç 10
    if (sort) dbQuery = dbQuery.sort(sort);

    const animeList = await dbQuery;
    const uniqueAnime = Array.from(
      new Map(
        animeList
          .filter(item => item.imdbID) // –§–∏–ª—å—Ç—Ä—É–µ–º –∑–∞–ø–∏—Å–∏ –±–µ–∑ imdbID
          .map(item => [item.imdbID, item])
      ).values()
    ).map(anime => ({
      ...anime.toObject(),
      Genre: Array.isArray(anime.Genre) ? anime.Genre : (anime.Genre ? [anime.Genre] : []), // –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ Genre ‚Äî –º–∞—Å—Å–∏–≤
    }));

    if (uniqueAnime.length === 0) return res.status(404).json({ message: '–ê–Ω–∏–º–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' });
    res.json(uniqueAnime);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∞–Ω–∏–º–µ:', error);
    res.status(500).json({ message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∞–Ω–∏–º–µ', error });
  }
});

app.get('/api/anime/:imdbID', async (req, res) => {
  try {
    const { imdbID } = req.params;
    const anime = await Anime.findOne({ imdbID });
    if (!anime) return res.status(404).json({ message: '–ê–Ω–∏–º–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' });
    res.json(anime);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∞–Ω–∏–º–µ:', error);
    res.status(500).json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞', error });
  }
});

// –ü—Ä–æ–∫—Å–∏ –¥–ª—è AniList API
app.post('/api/anilist', async (req, res) => {
  try {
    const { query, variables } = req.body;
    console.log('üìå –ó–∞–ø—Ä–æ—Å –∫ AniList:', { query, variables });

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 8000);

    const response = await fetch('https://graphql.anilist.co', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify({ query, variables }),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      throw new Error(`AniList API –æ—Ç–≤–µ—Ç–∏–ª —Å—Ç–∞—Ç—É—Å–æ–º: ${response.status}`);
    }

    const data = await response.json();
    console.log('üìå –û—Ç–≤–µ—Ç –æ—Ç AniList:', data);

    const anilistMedia = data.data?.Page?.media || [];

    // –§—É–Ω–∫—Ü–∏—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏ –Ω–∞–∑–≤–∞–Ω–∏–π
    const normalizeTitle = (title) => {
      if (!title) return '';
      return title
        .toLowerCase()
        .replace(/season \d+/g, '') // –£–¥–∞–ª—è–µ–º "Season X"
        .replace(/part \d+/g, '')   // –£–¥–∞–ª—è–µ–º "Part X"
        .replace(/\s+/g, ' ')       // –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
        .replace(/[^\w\s]/g, '')    // –£–±–∏—Ä–∞–µ–º –∑–Ω–∞–∫–∏ –ø—Ä–µ–ø–∏–Ω–∞–Ω–∏—è
        .trim();
    };

    // –°–æ–±–∏—Ä–∞–µ–º –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è –∏–∑ AniList
    const titlesToSearch = anilistMedia.map(anime => ({
      romaji: normalizeTitle(anime.title.romaji),
      english: normalizeTitle(anime.title.english),
    }));

    // –ò—â–µ–º —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –≤ MongoDB
    const dbAnimeList = await Anime.find({}).select('Title TitleEng imdbID Backdrop Poster OverviewRu Episodes Year imdbRating Genre Status');
    
    // –ö–∞—Ä—Ç–∞ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π
    const dbAnimeMap = new Map();
    dbAnimeList.forEach(dbAnime => {
      if (dbAnime.Title) dbAnimeMap.set(normalizeTitle(dbAnime.Title), dbAnime);
      if (dbAnime.TitleEng) dbAnimeMap.set(normalizeTitle(dbAnime.TitleEng), dbAnime);
    });

    // –û–±–æ–≥–∞—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ AniList
    const enhancedMedia = anilistMedia.map(anime => {
      const normalizedRomaji = normalizeTitle(anime.title.romaji);
      const normalizedEnglish = normalizeTitle(anime.title.english);

      // –ò—â–µ–º —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø–æ –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–º –Ω–∞–∑–≤–∞–Ω–∏—è–º
      const dbAnime = dbAnimeMap.get(normalizedRomaji) || dbAnimeMap.get(normalizedEnglish);

      // –ï—Å–ª–∏ —Ç–æ—á–Ω–æ–≥–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –Ω–µ—Ç, –∏—â–µ–º —á–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
      if (!dbAnime) {
        for (const dbAnime of dbAnimeList) {
          const dbTitleNormalized = normalizeTitle(dbAnime.Title) || '';
          const dbTitleEngNormalized = normalizeTitle(dbAnime.TitleEng) || '';
          if (
            (normalizedRomaji && dbTitleNormalized.includes(normalizedRomaji)) ||
            (normalizedEnglish && dbTitleEngNormalized.includes(normalizedEnglish)) ||
            (normalizedRomaji && dbTitleEngNormalized.includes(normalizedRomaji)) ||
            (normalizedEnglish && dbTitleNormalized.includes(normalizedEnglish))
          ) {
            return {
              ...anime,
              title: { ru: dbAnime.Title, romaji: anime.title.romaji, english: anime.title.english, native: anime.title.native },
              imdbID: dbAnime.imdbID || null,
              backdrop: dbAnime.Backdrop || null,
              poster: dbAnime.Poster || anime.coverImage?.large,
              description: dbAnime.OverviewRu || anime.description,
              episodes: dbAnime.Episodes || anime.episodes,
              year: dbAnime.Year || null,
              rating: dbAnime.imdbRating || (anime.averageScore / 10),
              genres: dbAnime.Genre || [],
              status: dbAnime.Status || null,
            };
          }
        }
      }

      return {
        ...anime,
        title: { ru: dbAnime?.Title || anime.title.romaji || anime.title.english, romaji: anime.title.romaji, english: anime.title.english, native: anime.title.native },
        imdbID: dbAnime?.imdbID || null,
        backdrop: dbAnime?.Backdrop || null,
        poster: dbAnime?.Poster || anime.coverImage?.large,
        description: dbAnime?.OverviewRu || anime.description,
        episodes: dbAnime?.Episodes || anime.episodes,
        year: dbAnime?.Year || null,
        rating: dbAnime?.imdbRating || (anime.averageScore / 10),
        genres: dbAnime?.Genre || [],
        status: dbAnime?.Status || null,
      };
    });

    res.json({ ...data, data: { ...data.data, Page: { ...data.data.Page, media: enhancedMedia } } });
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ AniList:', error.message);
    if (error.name === 'AbortError') {
      res.status(504).json({ error: '–ó–∞–ø—Ä–æ—Å –∫ AniList –ø—Ä–µ–≤—ã—Å–∏–ª –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è' });
    } else {
      res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ AniList' });
    }
  }
});
// admin
// –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∞–Ω–∏–º–µ
app.get('/api/admin/anime', authenticateToken, isAdmin, async (req, res) => {
  console.log('Admin request for anime list by user:', req.user);
  try {
    const animeList = await Anime.find().select('Title TitleEng Poster Backdrop Year Released imdbRating imdbID Episodes Genre Tags OverviewRu');
    res.json(animeList);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –∞–Ω–∏–º–µ:', error);
    res.status(500).json({ message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –∞–Ω–∏–º–µ', error });
  }
});

// –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –∞–Ω–∏–º–µ
app.post('/api/admin/anime', authenticateToken, isAdmin, async (req, res) => {
  try {
    const animeData = req.body;
    if (!animeData.imdbID || !animeData.Title || !animeData.TitleEng || !animeData.Poster || !animeData.Year || !animeData.Released || !animeData.Genre || !animeData.OverviewRu) {
      return res.status(400).json({ message: '–í—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω—ã' });
    }
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º Genre –≤ –º–∞—Å—Å–∏–≤, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "Animation, Comedy, Romance" ‚Üí ["Animation", "Comedy", "Romance"])
    if (typeof animeData.Genre === 'string') {
      animeData.Genre = animeData.Genre.split(",").map(genre => genre.trim()).filter(Boolean);
    }
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º Episodes –≤ —á–∏—Å–ª–æ, –µ—Å–ª–∏ –æ–Ω–æ –µ—Å—Ç—å
    if (animeData.Episodes) {
      animeData.Episodes = parseInt(animeData.Episodes) || 0;
    }
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º Tags –≤ –º–∞—Å—Å–∏–≤, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞
    if (typeof animeData.Tags === 'string') {
      animeData.Tags = animeData.Tags.split(",").map(tag => tag.trim()).filter(Boolean);
    }

    const newAnime = new Anime(animeData);
    await newAnime.save();
    res.status(201).json(newAnime);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∞–Ω–∏–º–µ:', error);
    res.status(400).json({ message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∞–Ω–∏–º–µ', error });
  }
});

// –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∞–Ω–∏–º–µ
app.put('/api/admin/anime/:imdbID', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { imdbID } = req.params;
    const updatedData = req.body;

    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–∞ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    console.log('PUT /api/admin/anime/:imdbID - Received data:', updatedData);

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
    if (!updatedData.Title || !updatedData.TitleEng || !updatedData.Poster || !updatedData.Year || !updatedData.Released || !updatedData.OverviewRu) {
      return res.status(400).json({ message: '–û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è (Title, TitleEng, Poster, Year, Released, OverviewRu) –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∑–∞–ø–æ–ª–Ω–µ–Ω—ã' });
    }

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º Genre –≤ –º–∞—Å—Å–∏–≤, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞
    if (typeof updatedData.Genre === 'string') {
      updatedData.Genre = updatedData.Genre.split(",").map(genre => genre.trim()).filter(Boolean);
    }
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ Genre –Ω–µ –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤
    if (!updatedData.Genre || updatedData.Genre.length === 0) {
      return res.status(400).json({ message: '–ñ–∞–Ω—Ä—ã (Genre) –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É–∫–∞–∑–∞–Ω—ã' });
    }

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º Tags –≤ –º–∞—Å—Å–∏–≤, –µ—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞
    if (typeof updatedData.Tags === 'string') {
      updatedData.Tags = updatedData.Tags.split(",").map(tag => tag.trim()).filter(Boolean);
    }

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º Episodes –≤ —á–∏—Å–ª–æ, –µ—Å–ª–∏ –æ–Ω–æ –µ—Å—Ç—å
    if (updatedData.Episodes !== undefined && updatedData.Episodes !== null) {
      updatedData.Episodes = parseInt(updatedData.Episodes) || 0;
    }

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è (Backdrop, imdbRating)
    if (updatedData.Backdrop === "") {
      updatedData.Backdrop = undefined; // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º undefined –¥–ª—è –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ –ø–æ–ª—è
    }
    if (updatedData.imdbRating === "") {
      updatedData.imdbRating = undefined; // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º undefined –¥–ª—è –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ –ø–æ–ª—è
    }

    // –£–¥–∞–ª—è–µ–º –ø–æ–ª–µ _id, –µ—Å–ª–∏ –æ–Ω–æ —Å–ª—É—á–∞–π–Ω–æ –ø–µ—Ä–µ–¥–∞–Ω–æ –∏–∑ –∫–ª–∏–µ–Ω—Ç–∞
    delete updatedData._id;

    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –æ–±–Ω–æ–≤–ª—è–µ–º—ã–µ –ø–æ–ª—è —Ç–æ–ª—å–∫–æ —Ç–µ–º–∏, —á—Ç–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –≤ —Å—Ö–µ–º–µ
    const allowedUpdates = {
      Title: updatedData.Title,
      TitleEng: updatedData.TitleEng,
      Poster: updatedData.Poster,
      Backdrop: updatedData.Backdrop,
      Year: updatedData.Year,
      Released: updatedData.Released,
      imdbRating: updatedData.imdbRating,
      Episodes: updatedData.Episodes,
      Genre: updatedData.Genre,
      Tags: updatedData.Tags,
      OverviewRu: updatedData.OverviewRu,
    };

    const updatedAnime = await Anime.findOneAndUpdate(
      { imdbID },
      allowedUpdates, // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ –ø–æ–ª—è
      { new: true, runValidators: true }
    );

    if (!updatedAnime) {
      return res.status(404).json({ message: '–ê–Ω–∏–º–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' });
    }

    res.json(updatedAnime);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –∞–Ω–∏–º–µ:', error);
    res.status(400).json({ message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ –∞–Ω–∏–º–µ', error: error.message });
  }
});

// –£–¥–∞–ª–µ–Ω–∏–µ –∞–Ω–∏–º–µ
app.delete('/api/admin/anime/:imdbID', authenticateToken, isAdmin, async (req, res) => {
  try {
    const { imdbID } = req.params;
    const deletedAnime = await Anime.findOneAndDelete({ imdbID });
    if (!deletedAnime) return res.status(404).json({ message: '–ê–Ω–∏–º–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' });
    res.json({ message: '–ê–Ω–∏–º–µ —É–¥–∞–ª–µ–Ω–æ', imdbID });
  } catch (error) {
    res.status(400).json({ message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∞–Ω–∏–º–µ', error });
  }
});
module.exports = app;